import {
	LLVMAddFunction,
	LLVMAddGlobal,
	LLVMAppendBasicBlockInContext,
	LLVMArrayType2,
	LLVMBuildAdd,
	LLVMBuildAlloca,
	LLVMBuildBitCast,
	LLVMBuildBr,
	LLVMBuildCall2,
	LLVMBuildCondBr,
	LLVMBuildFAdd,
	LLVMBuildFDiv,
	LLVMBuildFMul,
	LLVMBuildFSub,
	LLVMBuildICmp,
	LLVMBuildLoad2,
	LLVMBuildMul,
	LLVMBuildRet,
	LLVMBuildSDiv,
	LLVMBuildStore,
	LLVMBuildSub,
	LLVMBuildUDiv,
	LLVMConstInt,
	LLVMConstReal,
	LLVMConstStringInContext2,
	LLVMContextCreate,
	LLVMCreateBuilderInContext,
	LLVMDeleteBasicBlock,
	LLVMDoubleTypeInContext,
	LLVMFloatTypeInContext,
	LLVMFunctionType,
	LLVMGetInsertBlock,
	LLVMGetIntTypeWidth,
	LLVMGetParam,
	LLVMGetTypeKind,
	LLVMInt16TypeInContext,
	LLVMInt1TypeInContext,
	LLVMInt32TypeInContext,
	LLVMInt64TypeInContext,
	LLVMInt8TypeInContext,
	LLVMModuleCreateWithNameInContext,
	LLVMPointerTypeInContext,
	LLVMPositionBuilderAtEnd,
	LLVMPrintModuleToString,
	LLVMSetGlobalConstant,
	LLVMSetInitializer,
	LLVMSetLinkage,
	LLVMTypeOf,
	LLVMVerifyFunction,
	LLVMVerifyModule,
	LLVMVoidTypeInContext
} from "./ffi";

type Pointer = any;

export enum Linkage {
	External = 0,
	Internal = 1,
}


/**
 * context for llvm objects
 */
export class Context {
	private ptr: Pointer;
	constructor() {
		this.ptr = LLVMContextCreate();
	}
	/**
	 * get the raw pointer
	 */
	get handle() { return this.ptr; }
}

/**
 module holds functions and global data
*/
export class Module {
private ptr: Pointer;
private context: Context;
private _funcs: Map<string, Func> = new Map();
	private _strCounter = 0;
	
	/**
	* Add a global string constant to the module.
	* @param value The string value.
	* @param name Optional symbol name. If not provided, autogenerated.
	* @returns A Value pointing to the start of the string.
	*/
	addGlobalString(value: string, name?: string): Value {
		if (!name) {
		name = `.str.${this._strCounter++}`;
		}
		const ctx = this.getContext();
		const i8 = Type.int8(ctx);
		const strBytes = Buffer.from(value + "\0");
		const strConst = LLVMConstStringInContext2(ctx.handle, strBytes, BigInt(strBytes.length), 1);
		const arrType = LLVMArrayType2(i8.handle, BigInt(strBytes.length));
		const global = LLVMAddGlobal(this.ptr, arrType, Buffer.from(name + "\0"));
		LLVMSetInitializer(global, strConst);
		LLVMSetGlobalConstant(global, true);
		return new Value(global, Type.pointer(ctx));
	}

	/**
	 create a new module
	 @param name name of the module
	 @param context llvm context
	*/
	constructor(name: string, context: Context) {
		this.context = context;
		this.ptr = LLVMModuleCreateWithNameInContext(Buffer.from(name + "\0"), context.handle);
	}

	/**
	 add a function to the module
	 @param name function name
	 @param fnType function type
	 @param opts options
	 @returns the function object
	*/
  createFunction(name: string, fnType: FunctionType, opts?: { linkage?: Linkage }): Func {
	const fnPtr = LLVMAddFunction(this.ptr, Buffer.from(name + "\0"), fnType.handle);
	if (!fnPtr) throw new Error(`failed to add function ${name} with type ${fnType.handle}`);

	LLVMSetLinkage(fnPtr, opts?.linkage || Linkage.External);

	const func = new Func(fnPtr, this, fnType);
	(func as any)._paramCount = fnType.params.length;
	this._funcs.set(name, func);
	return func;
  }

	/**
	 check if the module is valid
	*/
	verify(): void {
		if (LLVMVerifyModule(this.ptr, 0, null)) throw new Error("Module verification failed");
	}

	/**
	 get the ir as a string
	*/
	toString(): string {
		const cstr = LLVMPrintModuleToString(this.ptr);
		return cstr.toString();
	}

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }

	/**
	 get the context
	*/
	getContext() { return this.context; }

	/**
	 get a function by name
	 @param name function name
	 @returns the function object or undefined if not found
	*/
	getFunction(name: string): Func | undefined {
		return this._funcs.get(name);
	}
}

/**
 describes a function type
*/
export class FunctionType {
	private ptr: Pointer;
	public params: Type[];
	public readonly returnType: Type;

	/**
	 create a function type
	 @param params parameter types
	 @param ret return type
	 @param isVarArg is variadic
	*/
	constructor(params: Type[], ret: Type, isVarArg = false) {
		this.params = params;
		this.returnType = ret;
		const buf = params.length ? Buffer.allocUnsafe(params.length * 8) : Buffer.alloc(0);
		for (let i = 0; i < params.length; ++i) {
			const p = params[i];
			if (!p) throw new Error(`parameter at index ${i} is undefined`);
			buf.writeBigUInt64LE(BigInt(p.handle), i * 8);
		}
		this.ptr = LLVMFunctionType(ret.handle, buf, params.length, isVarArg);
	}

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }
}

/**
 represents a function in the module
*/
export class Func {
private ptr: Pointer;
private module: Module;
public type?: FunctionType;
	public readonly paramCount: number;

	/**
	 create a function object
	 @param ptr pointer to the function
	 @param module parent module
	*/
	constructor(ptr: Pointer, module: Module, type?: FunctionType) {
	this.ptr = ptr;
	this.module = module;
	this.type = type;
	this.paramCount = type ? type.params.length : 0;
	}

	/**
	 add a basic block to the function
	 @param name block name
	 @returns the basic block
	*/
	addBlock(name: string): BasicBlock {
		return new BasicBlock(LLVMAppendBasicBlockInContext(this.module.getContext().handle, this.ptr, Buffer.from(name + "\0")), this);
	}

	/**
	 get a function argument by index
	 @param idx argument index
	 @returns the value
	*/
	getArg(idx: number): Value {
		return new Value(LLVMGetParam(this.ptr, idx));
	}

	/**
	 get all function arguments as an array
	 @returns array of values
	*/
	getArgs(): Value[] {
		return Array.from({ length: this.paramCount }, (_, i) => this.getArg(i));
	}

	/**
	 check if the function is valid
	*/
	verify(): void {
		if (LLVMVerifyFunction(this.ptr, 0)) throw new Error("Function verification failed");
	}

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }
}

/**
 represents a basic block in a function
*/
export class BasicBlock {
	private ptr: Pointer;
	public readonly parent: Func | undefined;

	/**
	 create a basic block object
	 @param ptr pointer to the block
	 @param parent parent function
	*/
	constructor(ptr: Pointer, parent?: Func) {
		this.ptr = ptr;
		this.parent = parent;
	}

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }

	/**
	 * Erase this block from its parent function
	 */
	erase(): void {
		if (!this.parent) return;
		LLVMDeleteBasicBlock(this.ptr);
		this.ptr = null;
	}
}

export enum ICmpPredicate {
	EQ = 32,
	NE = 33,
	UGT = 34,
	UGE = 35,
	ULT = 36,
	ULE = 37,
	SGT = 38,
	SGE = 39,
	SLT = 40,
	SLE = 41
}

export class IRBuilder {
	private _context: Context;
	/**
	 * Bitcast a value to another type (pointer or int of same width)
	 * @param value The value to cast
	 * @param destType The destination type
	 * @param name Optional name for the result
	 * @returns The casted value
	 */
	bitcast(value: Value, destType: Type, name = "bitcasttmp"): Value {
		const ptr = LLVMBuildBitCast(this.ptr, value.handle, destType.handle, Buffer.from(name + "\0"));
		return new Value(ptr, destType);
	}
	private _currentFunc?: Func;

	/**
	 * Set the current function context for this builder
	 * @param func The function being built
	 */
	setCurrentFunc(func: Func) {
		this._currentFunc = func;
	}

	/**
	 * Set where new instructions will be added in the given block
	 * and track the parent function for getInsertBlock()
	 * @param bb the block to insert into
	 */
	insertInto(bb: BasicBlock): void {
		LLVMPositionBuilderAtEnd(this.ptr, bb.handle);
		this._currentFunc = bb.parent;
	}

	/**
	 integer comparison equal (==)
	*/
	icmpEQ(left: Value, right: Value, name = "icmp_eq"): Value {
		const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.EQ, left.handle, right.handle, Buffer.from(name + "\0"));
		return new Value(valPtr, Type.int1(this._context));
	}
	/**
	 * Get the current insertion block
	 * @returns the BasicBlock currently being inserted into, or undefined if not set
	 */
	getInsertBlock(): BasicBlock | undefined {
		if (typeof LLVMGetInsertBlock !== 'function') throw new Error('LLVMGetInsertBlock FFI not available');
		const blockPtr = LLVMGetInsertBlock(this.ptr);
		if (!blockPtr) return undefined;
		return new BasicBlock(blockPtr, this._currentFunc);
	}
	/**
	 integer comparison not equal (!=)
	*/
	icmpNE(left: Value, right: Value, name = "icmp_ne"): Value {
		const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.NE, left.handle, right.handle, Buffer.from(name + "\0"));
		return new Value(valPtr, Type.int1(this._context));
	}
  /**
   integer comparison signed less than (<)
   */
	icmpSLT(left: Value, right: Value, name = "icmp_slt"): Value {
	const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.SLT, left.handle, right.handle, Buffer.from(name + "\0"));
	return new Value(valPtr, Type.int1(this._context));
	}
  /**
   integer comparison signed less or equal (<=)
   */
	icmpSLE(left: Value, right: Value, name = "icmp_sle"): Value {
	const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.SLE, left.handle, right.handle, Buffer.from(name + "\0"));
	return new Value(valPtr, Type.int1(this._context));
	}
  /**
   integer comparison signed greater than (>)
   */
	icmpSGT(left: Value, right: Value, name = "icmp_sgt"): Value {
	const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.SGT, left.handle, right.handle, Buffer.from(name + "\0"));
	return new Value(valPtr, Type.int1(this._context));
	}
  /**
   integer comparison signed greater or equal (>=)
   */
	icmpSGE(left: Value, right: Value, name = "icmp_sge"): Value {
	const valPtr = LLVMBuildICmp(this.ptr, ICmpPredicate.SGE, left.handle, right.handle, Buffer.from(name + "\0"));
	return new Value(valPtr, Type.int1(this._context));
	}

	/**
	 call a function with arguments
	 @param fn the function to call
	 @param args array of argument values
	 @param name optional result name
	 @returns the result value
	*/
	call(fn: Func, args: Value[], name = "calltmp"): Value {
	const argPtrs = args.length ? Buffer.allocUnsafe(args.length * 8) : Buffer.alloc(0);
	for (let i = 0; i < args.length; ++i) {
	  argPtrs.writeBigUInt64LE(BigInt(args[i].handle), i * 8);
	}
	if (!fn.type) throw new Error("Func.type is required for IRBuilder.call");
	const fnType = fn.type.handle;
	const valPtr = LLVMBuildCall2(this.ptr, fnType, fn.handle, argPtrs, args.length, Buffer.from(name + "\0"));
	return new Value(valPtr, fn.type.returnType);
	}
	private ptr: Pointer;

	constructor(context: Context) {
		this.ptr = LLVMCreateBuilderInContext(context.handle);
		this._context = context;
	}


	/**
	 allocate memory on the stack
	 @param type the type to allocate
	 @param name variable name
	 @returns a pointer to the allocated memory
	 */
	alloca(type: Type, name = "alloca"): Value {
		return new Value(LLVMBuildAlloca(this.ptr, type.handle, Buffer.from(name + "\0")));
	}

	/**
	 store a value in memory
	 @param value the value to store
	 @param ptr the pointer to store to
	 */
	store(value: Value, ptr: Value): void {
		LLVMBuildStore(this.ptr, value.handle, ptr.handle);
	}

	/**
	 load a value from memory
	 @param type the type of the value to load
	 @param ptr the pointer to load from
	 @param name variable name
	 @returns the loaded value
	 */
	load(type: Type, ptr: Value, name = "load"): Value {
		return new Value(LLVMBuildLoad2(this.ptr, type.handle, ptr.handle, Buffer.from(name + "\0")), type);
	}

	/**
	 add two values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	add(a: Value, b: Value): Value {
		return new Value(LLVMBuildAdd(this.ptr, a.handle, b.handle, Buffer.from("addtmp\0")), a.getType());
	}

	/**
	 add two floating point values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	fadd(a: Value, b: Value): Value {
		return new Value(LLVMBuildFAdd(this.ptr, a.handle, b.handle, Buffer.from("faddtmp\0")), a.getType());
	}

	/**
	 subtract two floating point values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	fsub(a: Value, b: Value): Value {
		return new Value(LLVMBuildFSub(this.ptr, a.handle, b.handle, Buffer.from("fsubtmp\0")), a.getType());
	}

	/**
	 multiply two floating point values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	fmul(a: Value, b: Value): Value {
		return new Value(LLVMBuildFMul(this.ptr, a.handle, b.handle, Buffer.from("fmultmp\0")), a.getType());
	}

	/**
	 subtract two values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	sub(a: Value, b: Value): Value {
		return new Value(LLVMBuildSub(this.ptr, a.handle, b.handle, Buffer.from("subtmp\0")), a.getType());
	}

	/**
	 multiply two values
	 @param a first value
	 @param b second value
	 @returns the result value
	 */
	mul(a: Value, b: Value): Value {
		return new Value(LLVMBuildMul(this.ptr, a.handle, b.handle, Buffer.from("multmp\0")), a.getType());
	}

	/**
	 signed integer division
	 @param a numerator
	 @param b denominator
	 @returns the result value
	 */
	sdiv(a: Value, b: Value): Value {
		return new Value(LLVMBuildSDiv(this.ptr, a.handle, b.handle, Buffer.from("sdivtmp\0")), a.getType());
	}

	/**
	 unsigned integer division
	 @param a numerator
	 @param b denominator
	 @returns the result value
	 */
	udiv(a: Value, b: Value): Value {
		return new Value(LLVMBuildUDiv(this.ptr, a.handle, b.handle, Buffer.from("udivtmp\0")), a.getType());
	}

	/**
	 floating point division
	 @param a numerator
	 @param b denominator
	 @returns the result value
	 */
	fdiv(a: Value, b: Value): Value {
		return new Value(LLVMBuildFDiv(this.ptr, a.handle, b.handle, Buffer.from("fdivtmp\0")), a.getType());
	}

	/**
	 unconditional branch to a basic block
	 @param dest destination block
	 */
	br(dest: BasicBlock): void {
		LLVMBuildBr(this.ptr, dest.handle);
	}

	/**
	 conditional branch
	 @param cond condition value
	 @param thenBlock block if true
	 @param elseBlock block if false
	 */
	condBr(cond: Value, thenBlock: BasicBlock, elseBlock: BasicBlock): void {
		LLVMBuildCondBr(this.ptr, cond.handle, thenBlock.handle, elseBlock.handle);
	}

	/**
	 return from the function (with or without a value)
	 @param val the value to return (optional)
	 */
	ret(val?: Value): void {
		LLVMBuildRet(this.ptr, val ? val.handle : null);
	}
}

/**
represents a type in llvm
*/
export class Type {
	private ptr: Pointer;
	private kind: string;
	private bitWidth?: number;
	private elementType?: Type;

	private constructor(ptr: Pointer, kind: string, bitWidth?: number, elementType?: Type) {
        this.ptr = ptr;
        this.kind = kind;
        if (bitWidth !== undefined) this.bitWidth = bitWidth;
        if (elementType) this.elementType = elementType;
    }

	/**
	create a Type from a raw pointer (internal use)
	tries to infer kind/bitWidth for int/float/double/pointer/void
	*/	static fromRaw(ptr: Pointer): Type {
		const typeKind = LLVMGetTypeKind(ptr);

		enum LLVMTypeKind {
			Void = 0,
			Half = 1,
			Float = 2,
			Double = 3,
			X86_FP80 = 4,
			FP128 = 5,
			PPC_FP128 = 6,
			Label = 7,
			Integer = 8,
			Function = 9,
			Struct = 10,
			Array = 11,
			Pointer = 12,
			Vector = 13,
			Metadata = 14,
			X86_MMX = 15,
			Token = 16,
			ScalableVector = 17,
			BFloat = 18,
			X86_AMX = 19,
			TargetExt = 20
		}

		switch (typeKind) {
			case LLVMTypeKind.Void:
				return new Type(ptr, "void");
			case LLVMTypeKind.Float:
				return new Type(ptr, "float");
			case LLVMTypeKind.Double:
				return new Type(ptr, "double");
			case LLVMTypeKind.Pointer:
				return new Type(ptr, "pointer");
			case LLVMTypeKind.Integer:
				const width = LLVMGetIntTypeWidth(ptr);
				if (typeof width === 'number' && width > 0) {
					return new Type(ptr, `int${width}`, width);
				}
				return new Type(ptr, "int");
			default:
				return new Type(ptr, "unknown");
		}
	}

	/**
	 get i1 type
	*/
	static int1(context: Context): Type {
		return new Type(LLVMInt1TypeInContext(context.handle), "int1", 1);
	}

	/**
	 get i8 type
	*/
	static int8(context: Context): Type {
		return new Type(LLVMInt8TypeInContext(context.handle), "int8", 8);
	}

	/**
	 get i16 type
	*/
	static int16(context: Context): Type {
		return new Type(LLVMInt16TypeInContext(context.handle), "int16", 16);
	}

	/**
	 get i32 type
	*/
	static int32(context: Context): Type {
		return new Type(LLVMInt32TypeInContext(context.handle), "int32", 32);
	}

	/**
	 get i64 type
	*/
	static int64(context: Context): Type {
		return new Type(LLVMInt64TypeInContext(context.handle), "int64", 64);
	}
	/**
	 get the bit width for integer types (returns undefined for non-integer types)
	*/
	getBitWidth(): number | undefined {
		return this.bitWidth;
	}

	/**
	 get float type
	*/
	static float(context: Context): Type {
		return new Type(LLVMFloatTypeInContext(context.handle), "float");
	}

	/**
	 get double type
	*/
	static double(context: Context): Type {
		return new Type(LLVMDoubleTypeInContext(context.handle), "double");
	}

	/**
	 get void type
	*/
	static void(context: Context): Type {
		return new Type(LLVMVoidTypeInContext(context.handle), "void");
	}

	/**
	 get pointer type (opaque pointer in LLVM 21)
	 @param context LLVM context
	 @param addressSpace address space
	*/
	static pointer(context: Context, addressSpace = 0): Type {
        return new Type(LLVMPointerTypeInContext(context.handle, addressSpace), "pointer");
    }

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }

	getElementType(): Type | undefined {
        return this.elementType;
    }

	/**
	 check if this is an integer type, optionally with a specific bit width
	 @param width optional bit width to check
	*/
	isInt(width?: number): boolean {
		if (!this.kind.startsWith("int")) return false;
		if (width !== undefined) return this.bitWidth === width;
		return true;
	}

	/**
	 check if this is a float type
	*/
	isFloat(): boolean {
		return this.kind === "float";
	}

	/**
	 check if this is a double type
	*/
	isDouble(): boolean {
		return this.kind === "double";
	}

	/**
	 check if this is a pointer type
	*/
	isPointer(): boolean {
		return this.kind === "pointer";
	}

	/**
	 check if this is a void type
	*/
	isVoid(): boolean {
		return this.kind === "void";
	}
}

/**
 represents a value in llvm
*/
export class Value {
	private ptr: Pointer;
	private _type?: Type;

	/**
	 create a value object
	 @param ptr pointer to the value
	*/
	constructor(ptr: Pointer, type?: Type) {
		this.ptr = ptr;
		this._type = type;
	}

	/**
	 create an integer constant
	 @param type the integer type
	 @param value the value
	 @param isSignedOverride whether to treat the value as signed (optional), llvm-bun tries to infer
	 */
	static constInt(type: Type, value: number | bigint, isSignedOverride?: boolean): Value {
		let isSigned = true;
		const typeName = type.constructor.name.toLowerCase();
		if (typeName.includes('uint')) isSigned = false;
		if (isSignedOverride !== undefined) isSigned = isSignedOverride;
		const ptr = LLVMConstInt(type.handle, BigInt(value), isSigned);
		return new Value(ptr, type);
	}

	/**
	 create a floating point constant
	 @param type the float type
	 @param value the value
	 */
	static constFloat(type: Type, value: number): Value {
		const ptr = LLVMConstReal(type.handle, value);
		return new Value(ptr, type);
	}

	/**
	 get the type of this value
	*/
	getType(): Type {
		if (this._type) return this._type;
		return Type.fromRaw(LLVMTypeOf(this.ptr));
	}

	/**
	 get the raw pointer
	*/
	get handle() { return this.ptr; }
}

const LLVM = {
	Context,
	Module,
	FunctionType,
	Func,
	BasicBlock,
	IRBuilder,
	Type,
	Linkage
};

export default LLVM;
